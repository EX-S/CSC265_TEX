\documentclass[10pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}

\begin{document}

\begin{center}
{\bf \Large \bf CSC265H Assignment 1}\\
\end{center}

\noindent
Yibin Zhao\\
1002996261\\

%Statement on collab.

\begin{enumerate}

\item
	The idea of my algorithm is is basically a BFS on this binary tree B that starts from the root and go down 1 level per iteration. If the current node is nil then stop searching down. If the current node is smaller than the number $x$, then add 1 to the counter, which keeps track of the number of nodes which are larger then $x$, and add its left child and right child to a list of nodes for the next iteration. If the counter exceeds $k$, then return true. If there is no nodes to be performed on the next iteration and the counter does not exceed $k$, return false. Otherwise, keep iterating.

\item 
\begin{algorithmic}[1]
	\Function{Tree-Compare}{$B,x,k$}
		\State $i \gets 0$
		\State $r \gets B$.root
		\State Queue $Q$ \Comment{Initialize a queue}
		\State \Call{ENQUEUE}{$Q, r$} \Comment{Add the root of the tree tothe queue}
		\While{$i < k$ and \Call{Empty}{$Q$} $==$ FALSE} \Comment{The loop halts when $i$ reaches $k$ or the queue is empty}
			\State $r \gets$ \Call{DEQUEUE}{$Q$}
			\If{$r ==$ nil}
				\State continue
			\Else	\If{$r$.key $\leq x$}
				\State continue
			\Else \Comment{$r$.key $> x$}
				\State \Call{ENQUEUE}{$Q, r$.left}
				\State \Call{ENQUEUE}{$Q, r$.right}
				\State $i \gets i+1$
				\EndIf
			\EndIf
		\EndWhile
		\If{$i < k$}
			\State \Return False
		\Else
			\State \Return True
		\EndIf
	\EndFunction
\end{algorithmic}


\item %partial correctness

\item %O(k) time

\item %worst case lower bound

\end{enumerate}

\end{document}
